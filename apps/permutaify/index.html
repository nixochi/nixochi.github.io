<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"/>
  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
  <meta name="mobile-web-app-capable" content="yes"/>
  <title>BCC Permutahedron Voxelized Model (Full + Debug)</title>
  <style>
    /* CSS Variables - Dark mode only */
    :root {
      --bg-primary: #161617;
      --bg-secondary: #1c1c1e;
      --fg-primary: #f3f3f3;
      --fg-secondary: #b9b9b9;
      --border: #222224;
      --shadow: rgba(0,0,0,0.5);
      --backdrop-blur: rgba(28, 28, 30, 0.9);
      --radius: 12px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    html, body {
      height: 100vh;
      height: -webkit-fill-available;
      height: 100svh;
      overflow: hidden;
      touch-action: none;
      -ms-touch-action: none;
      -webkit-overflow-scrolling: touch;
    }

    body {
      background: var(--bg-primary);
      color: var(--fg-primary);
      font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    canvas {
      display: block;
      width: 100vw;
      width: -webkit-fill-available;
      width: 100svw;
      height: 100vh;
      height: -webkit-fill-available;
      height: 100svh;
      touch-action: none;
    }

    /* Floating Panel */
    .controls {
      position: absolute;
      top: 68px;
      left: 20px;
      left: max(20px, env(safe-area-inset-left));
      background: var(--backdrop-blur);
      -webkit-backdrop-filter: blur(16px);
      backdrop-filter: blur(16px);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px;
      z-index: 1000;
      min-width: 200px;
      max-width: calc(100vw - 40px);
      max-width: calc(100svw - 40px - env(safe-area-inset-left) - env(safe-area-inset-right));
      max-height: 80vh;
      max-height: -webkit-fill-available;
      max-height: 80svh;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all 0.3s ease;
    }

    .controls.expanded {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .controls > * {
      max-width: 100%;
      box-sizing: border-box;
    }

    /* Title */
    .panel-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--fg-primary);
      margin-bottom: 12px;
      display: block;
    }

    /* Control groups */
    .control-group {
      margin-bottom: 12px;
    }

    .control-group:last-child {
      margin-bottom: 0;
    }

    .control-label {
      font-size: 12px;
      color: var(--fg-secondary);
      margin-bottom: 4px;
      display: block;
    }

    /* Action buttons */
    .action-btn {
      width: 100%;
      padding: 8px 12px;
      margin-bottom: 8px;
      background: color-mix(in srgb, var(--bg-secondary) 80%, var(--border) 20%);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--fg-primary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: inherit;
      -webkit-appearance: none;
      appearance: none;
    }

    .action-btn:hover {
      background: color-mix(in srgb, var(--bg-secondary) 60%, var(--border) 40%);
      border-color: color-mix(in srgb, var(--border) 70%, var(--fg-secondary) 30%);
    }

    .action-btn:active {
      opacity: 0.8;
    }

    .action-btn:last-child {
      margin-bottom: 0;
    }

    /* Input styling */
    input[type=file] {
      display: none;
    }

    .input-row {
      display: flex;
      gap: 8px;
      align-items: stretch;
      width: 100%;
    }

    input[type=number] {
      flex: 1;
      min-width: 0;
      background: var(--bg-secondary);
      color: var(--fg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 13px;
      font-family: inherit;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
      -moz-appearance: textfield;
      box-sizing: border-box;
      transition: all 0.2s ease;
    }

    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    input[type=number]:focus {
      border-color: var(--fg-secondary);
    }

    .compute-btn {
      margin-bottom: 0;
      flex-shrink: 0;
      padding: 8px 16px;
      width: auto;
    }

    /* Stats display */
    .stats {
      font-size: 12px;
      color: var(--fg-secondary);
      line-height: 1.5;
    }

    .stats div {
      margin-bottom: 2px;
    }

    .stats div:last-child {
      margin-bottom: 0;
    }

    /* Dropzone styling */
    .dropzone {
      padding: 12px;
      border: 2px dashed var(--border);
      border-radius: 6px;
      text-align: center;
      color: var(--fg-secondary);
      font-size: 12px;
      transition: all 0.2s ease;
    }

    .dropzone.dragover {
      background: rgba(255,255,255,0.05);
      border-color: var(--fg-secondary);
    }

    /* Debug console */
    #debugConsole {
      position: absolute;
      bottom: 10px;
      bottom: max(10px, env(safe-area-inset-bottom));
      right: 10px;
      right: max(10px, env(safe-area-inset-right));
      width: 360px;
      max-width: calc(100vw - 20px);
      max-width: calc(100svw - 20px - env(safe-area-inset-left) - env(safe-area-inset-right));
      height: 180px;
      max-height: 30vh;
      max-height: 30svh;
      background: var(--backdrop-blur);
      -webkit-backdrop-filter: blur(16px);
      backdrop-filter: blur(16px);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 8px;
      color: var(--fg-secondary);
      font-family: ui-monospace, 'SF Mono', Monaco, 'Cascadia Mono', 'Courier New', monospace;
      font-size: 11px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      white-space: pre-wrap;
      line-height: 1.4;
      z-index: 10000;
    }

    #debugConsole::-webkit-scrollbar {
      width: 8px;
    }

    #debugConsole::-webkit-scrollbar-track {
      background: transparent;
    }

    #debugConsole::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    #debugConsole::-webkit-scrollbar-thumb:hover {
      background: var(--fg-secondary);
    }

    #debugConsole b.error { color: #ff6b6b; }
    #debugConsole b.warn { color: #ffd93d; }
    #debugConsole b.log { color: var(--fg-primary); }

    /* Custom scrollbar for controls panel */
    .controls::-webkit-scrollbar {
      width: 8px;
    }

    .controls::-webkit-scrollbar-track {
      background: transparent;
    }

    .controls::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    .controls::-webkit-scrollbar-thumb:hover {
      background: var(--fg-secondary);
    }

    /* Top buttons */
    .top-left-buttons {
      position: absolute;
      top: 20px;
      top: max(20px, env(safe-area-inset-top));
      left: 20px;
      left: max(20px, env(safe-area-inset-left));
      display: flex;
      gap: 8px;
      z-index: 1001;
    }

    .top-right-buttons {
      position: absolute;
      top: 20px;
      top: max(20px, env(safe-area-inset-top));
      right: 20px;
      right: max(20px, env(safe-area-inset-right));
      display: flex;
      gap: 8px;
      z-index: 1001;
    }

    .options-button {
      background: var(--backdrop-blur);
      -webkit-backdrop-filter: blur(16px);
      backdrop-filter: blur(16px);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 16px;
      font-size: 13px;
      font-weight: 500;
      color: var(--fg-primary);
      cursor: pointer;
      font-family: inherit;
      transition: all 0.2s ease;
      -webkit-appearance: none;
      appearance: none;
    }

    .options-button:hover {
      background: color-mix(in srgb, var(--bg-secondary) 60%, var(--border) 40%);
      border-color: color-mix(in srgb, var(--border) 70%, var(--fg-secondary) 30%);
    }

    .options-button:active {
      opacity: 0.8;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .top-left-buttons {
        top: 15px;
        left: 15px;
      }

      .top-right-buttons {
        top: 15px;
        right: 15px;
      }

      .controls {
        top: 60px;
        left: 15px;
        padding: 12px;
        min-width: 180px;
        max-height: 60vh;
        max-height: -webkit-fill-available;
        max-height: 60svh;
      }

      #debugConsole {
        display: none;
      }

      .compute-btn {
        padding: 8px 12px;
        font-size: 12px;
      }

      .options-button {
        padding: 6px 10px;
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <!-- Top Left Buttons -->
  <div class="top-left-buttons">
    <button class="options-button" id="optionsBtn">Options</button>
  </div>

  <!-- Top Right Buttons -->
  <div class="top-right-buttons">
    <button class="options-button" id="restart">Restart Animation</button>
  </div>

  <div class="controls" id="controlsPanel">
    <span class="panel-title">BCC Permutahedron Voxelization</span>

    <div class="control-group">
      <label class="control-label">Model</label>
      <input type="file" id="fileInput" accept=".obj" style="display: none;">
      <button class="action-btn" id="uploadBtn">Upload OBJ File</button>
      <div id="dropzone" class="dropzone">or drag & drop .OBJ here</div>
    </div>

    <div class="control-group">
      <label class="control-label">Scale</label>
      <div class="input-row">
        <input type="number" id="scaleInput" min="0.1" max="100" step="0.1" value="1">
        <button class="action-btn compute-btn" id="computeBtn">Compute</button>
      </div>
    </div>

    <div class="control-group">
      <label class="control-label">Statistics</label>
      <div class="stats">
        <div>Total Voxels: <span id="totalCubes">0</span></div>
        <div>Visible Voxels: <span id="visibleCubes">0</span></div>
        <div>Lattice: BCC (a = 2)</div>
        <div>Voxelization: <span id="voxelTime">--</span></div>
      </div>
    </div>
  </div>
  <div id="debugConsole"></div>

  <script>
    // --- On-screen debug console ---
    (function(){
      const box=document.getElementById('debugConsole');
      const add=(msg,cls='log')=>{
        const e=document.createElement('div');
        e.innerHTML=`<b class="${cls}">[${cls.toUpperCase()}]</b> ${msg}`;
        box.appendChild(e);
        box.scrollTop=box.scrollHeight;
      };
      const wrap=(fn,cls)=>function(...a){add(a.map(x=>typeof x==='object'?JSON.stringify(x):x).join(' '),cls);fn.apply(console,a);};
      console.log=wrap(console.log,'log');
      console.warn=wrap(console.warn,'warn');
      console.error=wrap(console.error,'error');
      window.addEventListener('error',e=>add(e.message,'error'));
      window.addEventListener('unhandledrejection',e=>add('Promise: '+e.reason,'error'));
    })();

    // === WebGL setup ===
    const canvas=document.getElementById('canvas');
    const gl=canvas.getContext('webgl');
    if(!gl) alert('WebGL not supported');
    const ext=gl.getExtension('ANGLE_instanced_arrays');
    if(!ext) alert('Instanced rendering not supported');
    console.log("WebGL initialized");

    // --- Utility functions ---
    const sub=(a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]];
    const dot=(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2];
    const cross=(a,b)=>[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];
    const normalize=v=>{const L=Math.hypot(v[0],v[1],v[2]);return[v[0]/L,v[1]/L,v[2]/L];};

    // === OBJ parser ===
    function parseOBJ(text){
      const lines=text.split('\n');
      const vertices=[],faces=[];
      lines.forEach(line=>{
        line=line.trim();
        if(line.startsWith('v ')){
          const [,x,y,z]=line.split(/\s+/);
          vertices.push([+x,+y,+z]);
        } else if(line.startsWith('f ')){
          const parts=line.split(/\s+/).slice(1).map(p=>parseInt(p)-1);
          for(let i=1;i<parts.length-1;i++)faces.push([parts[0],parts[i],parts[i+1]]);
        }
      });
      console.log(`Parsed OBJ: ${vertices.length} vertices, ${faces.length} triangles`);
      return {vertices,faces};
    }

    // === Ray-triangle intersection ===
    function rayTriangleIntersect(orig,dir,v0,v1,v2){
      const EPS=1e-6;
      const e1=sub(v1,v0), e2=sub(v2,v0);
      const h=cross(dir,e2);
      const a=dot(e1,h);
      if(a>-EPS && a<EPS) return null;
      const f=1/a;
      const s=sub(orig,v0);
      const u=f*dot(s,h); if(u<0||u>1) return null;
      const q=cross(s,e1);
      const v=f*dot(dir,q); if(v<0||u+v>1) return null;
      const t=f*dot(e2,q);
      return t>EPS?t:null;
    }

    // === Spatial Grid for acceleration ===
    function buildSpatialGrid(model, cellSize) {
      const grid = new Map();
      const min = [Infinity, Infinity, Infinity];
      const max = [-Infinity, -Infinity, -Infinity];
      
      // Calculate bounds
      for (const v of model.vertices) {
        for (let i = 0; i < 3; i++) {
          min[i] = Math.min(min[i], v[i]);
          max[i] = Math.max(max[i], v[i]);
        }
      }
      
      // Hash function for grid cells
      const hash = (x, y, z) => `${x}|${y}|${z}`;
      const toCell = (x, y, z) => [
        Math.floor(x / cellSize),
        Math.floor(y / cellSize),
        Math.floor(z / cellSize)
      ];
      
      // Insert each triangle into grid cells it touches
      for (let faceIdx = 0; faceIdx < model.faces.length; faceIdx++) {
        const face = model.faces[faceIdx];
        const v0 = model.vertices[face[0]];
        const v1 = model.vertices[face[1]];
        const v2 = model.vertices[face[2]];
        
        // Find bounding box of triangle
        const tMin = [
          Math.min(v0[0], v1[0], v2[0]),
          Math.min(v0[1], v1[1], v2[1]),
          Math.min(v0[2], v1[2], v2[2])
        ];
        const tMax = [
          Math.max(v0[0], v1[0], v2[0]),
          Math.max(v0[1], v1[1], v2[1]),
          Math.max(v0[2], v1[2], v2[2])
        ];
        
        // Add triangle to all cells it overlaps
        const cMin = toCell(tMin[0], tMin[1], tMin[2]);
        const cMax = toCell(tMax[0], tMax[1], tMax[2]);
        
        for (let cx = cMin[0]; cx <= cMax[0]; cx++) {
          for (let cy = cMin[1]; cy <= cMax[1]; cy++) {
            for (let cz = cMin[2]; cz <= cMax[2]; cz++) {
              const key = hash(cx, cy, cz);
              if (!grid.has(key)) {
                grid.set(key, []);
              }
              grid.get(key).push(faceIdx);
            }
          }
        }
      }
      
      return { grid, cellSize, hash, toCell };
    }

    // === Point-in-mesh test (with spatial acceleration) ===
    function pointInMeshAccelerated(p, model, spatialGrid) {
      const dir = normalize([1, 0.123456789, 0.987654321]);
      const cell = spatialGrid.toCell(p[0], p[1], p[2]);
      
      // Collect all potentially intersecting triangles along ray path
      const checkedFaces = new Set();
      let count = 0;
      
      // Check cells along ray direction (simplified: check nearby cells)
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          for (let dz = -1; dz <= 1; dz++) {
            const key = spatialGrid.hash(cell[0] + dx, cell[1] + dy, cell[2] + dz);
            const faceIndices = spatialGrid.grid.get(key);
            
            if (faceIndices) {
              for (const faceIdx of faceIndices) {
                if (checkedFaces.has(faceIdx)) continue;
                checkedFaces.add(faceIdx);
                
                const face = model.faces[faceIdx];
                const t = rayTriangleIntersect(
                  p, dir,
                  model.vertices[face[0]],
                  model.vertices[face[1]],
                  model.vertices[face[2]]
                );
                if (t !== null) count++;
              }
            }
          }
        }
      }
      
      // Need to check farther cells if ray extends beyond local neighborhood
      // For now, also do a full scan but only on faces not yet checked
      for (let faceIdx = 0; faceIdx < model.faces.length; faceIdx++) {
        if (checkedFaces.has(faceIdx)) continue;
        
        const face = model.faces[faceIdx];
        const t = rayTriangleIntersect(
          p, dir,
          model.vertices[face[0]],
          model.vertices[face[1]],
          model.vertices[face[2]]
        );
        if (t !== null) count++;
      }
      
      return (count % 2) === 1;
    }

    // === Voxelization (BCC lattice with spatial acceleration) ===
    const CELL_R = Math.sqrt(1.25);
    
    function voxelizeModel(model) {
      const min = [Infinity, Infinity, Infinity];
      const max = [-Infinity, -Infinity, -Infinity];
      
      for (const v of model.vertices) {
        for (let i = 0; i < 3; i++) {
          min[i] = Math.min(min[i], v[i]);
          max[i] = Math.max(max[i], v[i]);
        }
      }
      
      console.log("Building spatial grid...");
      const gridStart = performance.now();
      // Cell size = average edge length of model / 4 (heuristic)
      const extent = Math.max(max[0] - min[0], max[1] - min[1], max[2] - min[2]);
      const cellSize = extent / 8;
      const spatialGrid = buildSpatialGrid(model, cellSize);
      console.log(`Grid built: ${spatialGrid.grid.size} cells, ${(performance.now() - gridStart).toFixed(1)} ms`);
      
      const vox = [];
      const set = new Set();
      
      console.log("Voxelizing within", min, max);
      const start = performance.now();
      
      for (let xo = 0; xo < 2; xo++) {
        for (let yo = 0; yo < 2; yo++) {
          for (let zo = 0; zo < 2; zo++) {
            if ((xo + yo + zo) % 2 !== 0) continue;
            
            for (let x = min[0] - 1 + xo; x <= max[0] + 1; x += 2) {
              for (let y = min[1] - 1 + yo; y <= max[1] + 1; y += 2) {
                for (let z = min[2] - 1 + zo; z <= max[2] + 1; z += 2) {
                  const key = `${x},${y},${z}`;
                  if (!set.has(key) && pointInMeshAccelerated([x, y, z], model, spatialGrid)) {
                    set.add(key);
                    vox.push(x, y, z);
                  }
                }
              }
            }
          }
        }
      }
      
      const elapsed = (performance.now() - start).toFixed(1);
      console.log(`Voxelization complete: ${vox.length / 3} voxels, ${elapsed} ms`);
      document.getElementById('voxelTime').textContent = `${elapsed} ms`;
      
      return new Float32Array(vox);
    }

    // === Geometry (permutahedron) ===
    const permutahedronVertices=new Float32Array([
      1,0.5,0,1,-0.5,0,-1,0.5,0,-1,-0.5,0,
      1,0,0.5,1,0,-0.5,-1,0,0.5,-1,0,-0.5,
      0.5,1,0,0.5,-1,0,-0.5,1,0,-0.5,-1,0,
      0.5,0,1,0.5,0,-1,-0.5,0,1,-0.5,0,-1,
      0,1,0.5,0,1,-0.5,0,-1,0.5,0,-1,-0.5,
      0,0.5,1,0,0.5,-1,0,-0.5,1,0,-0.5,-1
    ]);
    const permutahedronFaces=[
      [15,21,13,23],[12,20,14,22],[5,1,9,19,23,13],[17,8,0,5,13,21],
      [11,3,7,15,23,19],[11,19,9,18],[6,3,11,18,22,14],[6,2,7,3],
      [4,12,22,18,9,1],[4,1,5,0],[10,17,21,15,7,2],[16,8,17,10],
      [16,10,2,6,14,20],[16,20,12,4,0,8]
    ];
    function triangulate(faces){
      const idx=[];
      faces.forEach(f=>{for(let i=1;i<f.length-1;i++)idx.push(f[0],f[i],f[i+1]);});
      return new Uint16Array(idx);
    }
    const permutahedronIndices=triangulate(permutahedronFaces);

    function generateEdges(faces){
      const edges=new Set(),v=permutahedronVertices;
      faces.forEach(face=>{
        for(let i=0;i<face.length;i++){
          const a=face[i],b=face[(i+1)%face.length];
          const key=a<b?`${a}-${b}`:`${b}-${a}`;edges.add(key);
        }
      });
      const eVerts=[];
      edges.forEach(k=>{
        const [a,b]=k.split('-').map(Number);
        eVerts.push(
          v[a*3],v[a*3+1],v[a*3+2],
          v[b*3],v[b*3+1],v[b*3+2]
        );
      });
      return new Float32Array(eVerts);
    }
    const permutahedronEdges=generateEdges(permutahedronFaces);
    const combinedVerts=new Float32Array([...permutahedronVertices,...permutahedronEdges]);
    const combinedTypes=new Float32Array(
      Array(permutahedronVertices.length/3).fill(0).concat(
        Array(permutahedronEdges.length/3).fill(1)
      )
    );

    // === Shaders ===
    function compile(src,type){
      const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);
      if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))console.error(gl.getShaderInfoLog(s));
      return s;
    }
    const vsh=compile(`
      attribute vec3 aPosition;
      attribute vec3 aInstancePosition;
      attribute float aDelay;
      attribute float aType;
      uniform mat4 uProjection,uView;
      uniform float uTime;
      varying vec3 vColor;
      varying float vType;
      vec3 hsv2rgb(vec3 c){
        vec4 K=vec4(1.,2./3.,1./3.,3.);
        vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);
        return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);
      }
      void main(){
        float d=uTime-aDelay;
        float f=clamp(d/0.8,0.,1.);
        float eased=1.-pow(1.-f,3.);
        vec3 pos=aInstancePosition;pos.y+=150.*(1.-eased);
        vec3 world=aPosition+pos;
        vec3 normal=normalize(world);
        vec3 light=normalize(vec3(1.,1.,1.));
        float diff=max(dot(normal,light),0.4);
        float hue=clamp((aInstancePosition.y+15.)/30.,0.,1.)*0.833;
        vColor=hsv2rgb(vec3(hue,1.,1.))*diff;
        vType=aType;
        gl_Position=uProjection*uView*vec4(world,1.);
      }`,gl.VERTEX_SHADER);
    const fsh=compile(`precision mediump float;
      varying vec3 vColor; varying float vType;
      void main(){gl_FragColor=(vType>0.5)?vec4(0,0,0,1):vec4(vColor,1);}
    `,gl.FRAGMENT_SHADER);
    const prog=gl.createProgram();
    gl.attachShader(prog,vsh);gl.attachShader(prog,fsh);gl.linkProgram(prog);
    gl.useProgram(prog);

    // === Buffers ===
    const aPos=gl.getAttribLocation(prog,'aPosition');
    const aInstPos=gl.getAttribLocation(prog,'aInstancePosition');
    const aDelay=gl.getAttribLocation(prog,'aDelay');
    const aType=gl.getAttribLocation(prog,'aType');
    const uProj=gl.getUniformLocation(prog,'uProjection');
    const uView=gl.getUniformLocation(prog,'uView');
    const uTime=gl.getUniformLocation(prog,'uTime');

    const bufVerts=gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER,bufVerts);
    gl.bufferData(gl.ARRAY_BUFFER,combinedVerts,gl.STATIC_DRAW);
    gl.enableVertexAttribArray(aPos);
    gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,0,0);
    ext.vertexAttribDivisorANGLE(aPos,0);

    const bufType=gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER,bufType);
    gl.bufferData(gl.ARRAY_BUFFER,combinedTypes,gl.STATIC_DRAW);
    gl.enableVertexAttribArray(aType);
    gl.vertexAttribPointer(aType,1,gl.FLOAT,false,0,0);
    ext.vertexAttribDivisorANGLE(aType,0);

    const bufIdx=gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,bufIdx);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,permutahedronIndices,gl.STATIC_DRAW);

    const bufInst=gl.createBuffer();
    const bufDelay=gl.createBuffer();

    function perspective(fov,asp,n,f){const t=Math.tan(fov/2),r=t*asp;
      const a=1/t,b=1/(n-f);
      return new Float32Array([a/asp,0,0,0, 0,a,0,0, 0,0,(n+f)*b,-1, 0,0,2*n*f*b,0]);
    }
    function lookAt(e,c,u){
      const z=normalize(sub(e,c)),x=normalize(cross(u,z)),y=cross(z,x);
      return new Float32Array([
        x[0],y[0],z[0],0,
        x[1],y[1],z[1],0,
        x[2],y[2],z[2],0,
        -dot(x,e),-dot(y,e),-dot(z,e),1
      ]);
    }
    function resize(){
      canvas.width=innerWidth;canvas.height=innerHeight;
      gl.viewport(0,0,canvas.width,canvas.height);
      proj=perspective(Math.PI/4,canvas.width/canvas.height,0.1,1000);
    }
    window.addEventListener('resize',resize);
    let proj;resize();

    function calcDelays(pos){
      let minY=Infinity,maxY=-Infinity;
      for(let i=1;i<pos.length;i+=3){
        minY=Math.min(minY,pos[i]);
        maxY=Math.max(maxY,pos[i]);
      }

      const d=[];
      const yRange=maxY-minY||1;
      for(let i=0;i<pos.length;i+=3){
        const x=pos[i],y=pos[i+1],z=pos[i+2];
        const normalizedY=(y-minY)/yRange;
        let delay=normalizedY*2.5+Math.sin(x*12.3+z*45.6)*0.3+Math.cos(x*23.4+y*34.5)*0.2;
        d.push(delay);
      }
      return new Float32Array(d);
    }

    let instPos=new Float32Array(),instDel=new Float32Array();
    function updateInstances(vox){
      instPos=vox;
      instDel=calcDelays(vox);
      
      // Upload once with STATIC_DRAW since data doesn't change after voxelization
      gl.bindBuffer(gl.ARRAY_BUFFER, bufInst);
      gl.bufferData(gl.ARRAY_BUFFER, instPos, gl.STATIC_DRAW);
      
      gl.bindBuffer(gl.ARRAY_BUFFER, bufDelay);
      gl.bufferData(gl.ARRAY_BUFFER, instDel, gl.STATIC_DRAW);
      
      document.getElementById('totalCubes').textContent=vox.length/3;
      console.log("Updated instance buffers:",vox.length/3);
    }

    // === Default model data ===
    const defaultOBJ = `# Generated OBJ for Permutahedron (scaled by 15.0)
o Permutahedron
v 15.000000 7.500000 0.000000
v 15.000000 -7.500000 0.000000
v -15.000000 7.500000 0.000000
v -15.000000 -7.500000 0.000000
v 15.000000 0.000000 7.500000
v 15.000000 0.000000 -7.500000
v -15.000000 0.000000 7.500000
v -15.000000 0.000000 -7.500000
v 7.500000 15.000000 0.000000
v 7.500000 -15.000000 0.000000
v -7.500000 15.000000 0.000000
v -7.500000 -15.000000 0.000000
v 7.500000 0.000000 15.000000
v 7.500000 0.000000 -15.000000
v -7.500000 0.000000 15.000000
v -7.500000 0.000000 -15.000000
v 0.000000 15.000000 7.500000
v 0.000000 15.000000 -7.500000
v 0.000000 -15.000000 7.500000
v 0.000000 -15.000000 -7.500000
v 0.000000 7.500000 15.000000
v 0.000000 7.500000 -15.000000
v 0.000000 -7.500000 15.000000
v 0.000000 -7.500000 -15.000000
f 16 22 14 24
f 13 21 15 23
f 6 2 10 20 24 14
f 18 9 1 6 14 22
f 12 4 8 16 24 20
f 12 20 10 19
f 7 4 12 19 23 15
f 7 3 8 4
f 5 13 23 19 10 2
f 5 2 6 1
f 11 18 22 16 8 3
f 17 9 18 11
f 17 11 3 7 15 21
f 17 21 13 5 1 9
l 16 22
l 14 22
l 14 24
l 16 24
l 13 21
l 15 21
l 15 23
l 13 23
l 2 6
l 2 10
l 10 20
l 20 24
l 6 14
l 9 18
l 1 9
l 1 6
l 18 22
l 4 12
l 4 8
l 8 16
l 12 20
l 10 19
l 12 19
l 4 7
l 19 23
l 7 15
l 3 7
l 3 8
l 5 13
l 2 5
l 1 5
l 11 18
l 3 11
l 9 17
l 11 17
l 17 21`;

    // === Scale and model management ===
    let currentModel=null;
    let modelScale=1.0;

    function centerModel(model){
      const min=[Infinity,Infinity,Infinity];
      const max=[-Infinity,-Infinity,-Infinity];
      model.vertices.forEach(v=>{
        for(let i=0;i<3;i++){
          min[i]=Math.min(min[i],v[i]);
          max[i]=Math.max(max[i],v[i]);
        }
      });

      const center=[
        (min[0]+max[0])/2,
        (min[1]+max[1])/2,
        (min[2]+max[2])/2
      ];

      console.log(`Model bounds: min=${min}, max=${max}, center=${center}`);

      const centeredModel={vertices:[],faces:model.faces};
      model.vertices.forEach(v=>{
        centeredModel.vertices.push([
          v[0]-center[0],
          v[1]-center[1],
          v[2]-center[2]
        ]);
      });

      return centeredModel;
    }

    function applyScale(model,scale){
      const scaledModel={vertices:[],faces:model.faces};
      model.vertices.forEach(v=>{
        scaledModel.vertices.push([v[0]*scale,v[1]*scale,v[2]*scale]);
      });
      return scaledModel;
    }

    function processModel(){
      if(!currentModel)return;
      const centered=centerModel(currentModel);
      const scaled=applyScale(centered,modelScale);
      const vox=voxelizeModel(scaled);
      updateInstances(vox);
    }

    // === File upload ===
    const fileInput=document.getElementById('fileInput');
    const uploadBtn=document.getElementById('uploadBtn');
    const drop=document.getElementById('dropzone');
    const scaleInput=document.getElementById('scaleInput');
    const computeBtn=document.getElementById('computeBtn');

    uploadBtn.addEventListener('click',()=>fileInput.click());
    fileInput.addEventListener('change',e=>{if(e.target.files[0])loadOBJ(e.target.files[0]);});
    drop.addEventListener('dragover',e=>{e.preventDefault();drop.classList.add('dragover');});
    drop.addEventListener('dragleave',()=>drop.classList.remove('dragover'));
    drop.addEventListener('drop',e=>{
      e.preventDefault();drop.classList.remove('dragover');
      if(e.dataTransfer.files[0])loadOBJ(e.dataTransfer.files[0]);
    });

    function applyScaleChange(){
      const val=parseFloat(scaleInput.value);
      if(val>0){
        modelScale=val;
        processModel();
      }
    }

    computeBtn.addEventListener('click',applyScaleChange);
    scaleInput.addEventListener('keydown',e=>{
      if(e.key==='Enter'){
        applyScaleChange();
      }
    });

    function loadOBJ(file){
      console.log("Loading file:",file.name);
      const r=new FileReader();
      r.onload=()=>{
        currentModel=parseOBJ(r.result);
        processModel();
      };
      r.readAsText(file);
    }

    // === Options panel toggle ===
    const optionsBtn=document.getElementById('optionsBtn');
    const controlsPanel=document.getElementById('controlsPanel');
    let panelVisible=false;

    optionsBtn.addEventListener('click',()=>{
      panelVisible=!panelVisible;
      if(panelVisible){
        controlsPanel.classList.add('expanded');
        optionsBtn.textContent='Close';
      }else{
        controlsPanel.classList.remove('expanded');
        optionsBtn.textContent='Options';
      }
    });

    // === Camera controls ===
    let camDist=54;
    const minDist=10,maxDist=200;

    canvas.addEventListener('wheel',e=>{
      e.preventDefault();
      camDist+=e.deltaY*0.05;
      camDist=Math.max(minDist,Math.min(maxDist,camDist));
    },{passive:false});

    let touchDist=null;
    canvas.addEventListener('touchstart',e=>{
      if(e.touches.length===2){
        const dx=e.touches[0].clientX-e.touches[1].clientX;
        const dy=e.touches[0].clientY-e.touches[1].clientY;
        touchDist=Math.hypot(dx,dy);
      }
    },{passive:true});

    canvas.addEventListener('touchmove',e=>{
      if(e.touches.length===2&&touchDist!==null){
        e.preventDefault();
        const dx=e.touches[0].clientX-e.touches[1].clientX;
        const dy=e.touches[0].clientY-e.touches[1].clientY;
        const newDist=Math.hypot(dx,dy);
        const delta=(touchDist-newDist)*0.5;
        camDist+=delta;
        camDist=Math.max(minDist,Math.min(maxDist,camDist));
        touchDist=newDist;
      }
    },{passive:false});

    canvas.addEventListener('touchend',e=>{
      if(e.touches.length<2)touchDist=null;
    },{passive:true});

    // === Animation loop ===
    let time=0;
    document.getElementById('restart').onclick=()=>time=0;

    function render(){
      time+=0.016;
      gl.clearColor(0.086,0.086,0.09,1);
      gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.DEPTH_TEST);
      gl.enable(gl.CULL_FACE);

      const camX=Math.cos(time*0.3)*camDist,camZ=Math.sin(time*0.3)*camDist;
      const view=lookAt([camX,10,camZ],[0,0,0],[0,1,0]);
      gl.uniformMatrix4fv(uProj,false,proj);
      gl.uniformMatrix4fv(uView,false,view);
      gl.uniform1f(uTime,time);

      // Bind buffers (already uploaded in updateInstances)
      gl.bindBuffer(gl.ARRAY_BUFFER,bufInst);
      gl.enableVertexAttribArray(aInstPos);
      gl.vertexAttribPointer(aInstPos,3,gl.FLOAT,false,0,0);
      ext.vertexAttribDivisorANGLE(aInstPos,1);

      gl.bindBuffer(gl.ARRAY_BUFFER,bufDelay);
      gl.enableVertexAttribArray(aDelay);
      gl.vertexAttribPointer(aDelay,1,gl.FLOAT,false,0,0);
      ext.vertexAttribDivisorANGLE(aDelay,1);

      const count=instPos.length/3;
      document.getElementById('visibleCubes').textContent=count;

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,bufIdx);
      ext.drawElementsInstancedANGLE(gl.TRIANGLES,permutahedronIndices.length,gl.UNSIGNED_SHORT,0,count);
      const edgeOff=permutahedronVertices.length/3;
      ext.drawArraysInstancedANGLE(gl.LINES,edgeOff,permutahedronEdges.length/3,count);
      requestAnimationFrame(render);
    }
    render();

    // Load default model on startup
    console.log("Loading default permutahedron model...");
    currentModel = parseOBJ(defaultOBJ);
    processModel();
    console.log("Default model loaded. Ready for OBJ upload.");
  </script>
</body>
</html>