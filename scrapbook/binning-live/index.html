<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Camera Binning with Histogram</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            min-height: 100vh;
            min-height: 100svh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            padding: max(20px, env(safe-area-inset-top)) max(20px, env(safe-area-inset-right)) max(20px, env(safe-area-inset-bottom)) max(20px, env(safe-area-inset-left));
            -webkit-overflow-scrolling: touch;
            -webkit-user-select: none;
            user-select: none;
            overflow-x: hidden;
        }

        .container {
            max-width: 900px;
            width: 100%;
        }

        .canvas-container {
            width: 100%;
            max-width: 640px;
            margin: 0 auto 20px;
            border: 1px solid #333;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #histogramCanvas {
            width: 100%;
            max-width: 640px;
            height: 60px;
            margin: 0 auto 30px;
            border: 1px solid #333;
        }

        .controls {
            max-width: 400px;
            margin: 0 auto;
        }

        .control-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            color: #888;
            margin-bottom: 12px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        input[type="range"] {
            flex: 1;
            height: 2px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            touch-action: pan-x;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.3);
            -webkit-transform: scale(1.3);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.5);
            -webkit-transform: scale(1.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.3);
        }

        input[type="range"]::-moz-range-thumb:active {
            transform: scale(1.5);
        }

        .value-display {
            font-size: 16px;
            color: #fff;
            min-width: 30px;
            text-align: center;
            font-weight: 300;
        }

        .button-row {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 10px;
            font-size: 11px;
            font-weight: 400;
            border: 1px solid #333;
            background: #000;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.1);
            touch-action: manipulation;
        }

        button:hover:not(:disabled) {
            border-color: #fff;
            background: #111;
        }

        button:active:not(:disabled) {
            transform: scale(0.98);
            -webkit-transform: scale(0.98);
        }

        button:disabled {
            color: #555;
            border-color: #222;
            cursor: not-allowed;
        }

        #uploadButton {
            position: relative;
        }

        #uploadInput {
            display: none;
        }

        .error {
            background: #200;
            color: #f88;
            padding: 12px;
            margin-top: 20px;
            display: none;
            font-size: 12px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-container">
            <canvas id="glCanvas" width="640" height="480"></canvas>
        </div>

        <canvas id="histogramCanvas" width="640" height="60"></canvas>

        <div class="controls">
            <div class="control-group">
                <label for="binsSlider">Bins per Channel</label>
                <div class="slider-container">
                    <input type="range" id="binsSlider" min="2" max="11" value="11" step="1">
                    <span class="value-display" id="binsValue">11</span>
                </div>
            </div>

            <div class="control-group">
                <div class="button-row">
                    <button id="startButton">Start Camera</button>
                    <button id="uploadButton">Upload Photo</button>
                </div>
                <input type="file" id="uploadInput" accept="image/*">
            </div>
        </div>

        <div class="error" id="errorMessage"></div>
    </div>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        const histCanvas = document.getElementById('histogramCanvas');
        const histCtx = histCanvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const uploadButton = document.getElementById('uploadButton');
        const uploadInput = document.getElementById('uploadInput');
        const binsSlider = document.getElementById('binsSlider');
        const binsValue = document.getElementById('binsValue');
        const errorMessage = document.getElementById('errorMessage');

        let video = null;
        let texture = null;
        let binCentersTexture = null;
        let program = null;
        let binUniformLocation = null;
        let animationId = null;
        let currentBins = 11;
        let frameCount = 0;
        let vertexShaderSource = null;
        let fragmentShaderSource = null;
        let cameraActive = false;
        let uploadedImage = null;

        async function loadShader(url) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to load shader: ${url}`);
            }
            return await response.text();
        }

        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Pre-calculate all bin centers
        function generateBinCenters(bins) {
            const totalBins = bins * bins * bins;
            const centers = new Float32Array(totalBins * 3);
            
            let idx = 0;
            for (let b = 0; b < bins; b++) {
                for (let g = 0; g < bins; g++) {
                    for (let r = 0; r < bins; r++) {
                        centers[idx++] = (r + 0.5) / bins;
                        centers[idx++] = (g + 0.5) / bins;
                        centers[idx++] = (b + 0.5) / bins;
                    }
                }
            }
            return centers;
        }

        function updateBinCentersTexture(bins) {
            const centers = generateBinCenters(bins);
            const totalBins = bins * bins * bins;
            
            // Create RGB texture (totalBins x 1)
            const rgbData = new Uint8Array(totalBins * 3);
            for (let i = 0; i < totalBins * 3; i++) {
                rgbData[i] = Math.floor(centers[i] * 255);
            }
            
            gl.bindTexture(gl.TEXTURE_2D, binCentersTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, totalBins, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, rgbData);
        }

        async function initWebGL() {
            if (!gl) {
                showError('WebGL not supported in this browser');
                return false;
            }

            try {
                vertexShaderSource = await loadShader('vertex.glsl');
                fragmentShaderSource = await loadShader('fragment.glsl');
            } catch (err) {
                showError('Failed to load shaders: ' + err.message);
                return false;
            }

            const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);

            if (!vertexShader || !fragmentShader) {
                showError('Failed to compile shaders');
                return false;
            }

            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                showError('Failed to link program: ' + gl.getProgramInfoLog(program));
                return false;
            }

            gl.useProgram(program);

            const positions = new Float32Array([
                -1, -1,  1, -1,  -1, 1,
                -1, 1,   1, -1,   1, 1
            ]);

            const texCoords = new Float32Array([
                0, 1,  1, 1,  0, 0,
                0, 0,  1, 1,  1, 0
            ]);

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            const texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);

            const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
            gl.enableVertexAttribArray(texCoordLocation);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

            binUniformLocation = gl.getUniformLocation(program, 'u_bins');

            // Create video texture
            texture = gl.createTexture();
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.uniform1i(gl.getUniformLocation(program, 'u_texture'), 0);

            // Create bin centers texture
            binCentersTexture = gl.createTexture();
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, binCentersTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.uniform1i(gl.getUniformLocation(program, 'u_binCenters'), 1);
            
            updateBinCentersTexture(currentBins);

            return true;
        }

        function drawHistogram(binCounts, binCenters, bins) {
            const width = histCanvas.width;
            const height = histCanvas.height;
            
            // Clear with black background
            histCtx.fillStyle = '#000';
            histCtx.fillRect(0, 0, width, height);

            if (binCounts.length === 0) return;

            // Create array of {count, color} for non-empty bins
            const sorted = binCounts.map((count, idx) => ({
                count,
                color: binCenters.slice(idx * 3, idx * 3 + 3)
            })).filter(item => item.count > 0);

            // Sort by luminance (descending) - brightest first
            sorted.sort((a, b) => {
                const lumA = 0.299 * a.color[0] + 0.587 * a.color[1] + 0.114 * a.color[2];
                const lumB = 0.299 * b.color[0] + 0.587 * b.color[1] + 0.114 * b.color[2];
                return lumB - lumA;
            });

            const total = sorted.reduce((sum, item) => sum + item.count, 0);
            
            // Draw horizontal bar (left to right)
            let currentX = 0;
            sorted.forEach(item => {
                const proportion = item.count / total;
                const barWidth = proportion * width;
                
                const r = Math.floor(item.color[0] * 255);
                const g = Math.floor(item.color[1] * 255);
                const b = Math.floor(item.color[2] * 255);
                
                histCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                histCtx.fillRect(currentX, 0, barWidth, height);
                
                currentX += barWidth;
            });
        }

        function countBins(bins) {
            const totalBins = bins * bins * bins;
            const counts = new Array(totalBins).fill(0);
            
            const pixels = new Uint8Array(canvas.width * canvas.height * 4);
            gl.readPixels(0, 0, canvas.width, canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
            
            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i] / 255;
                const g = pixels[i + 1] / 255;
                const b = pixels[i + 2] / 255;
                
                const rbin = Math.min(Math.floor(r * bins), bins - 1);
                const gbin = Math.min(Math.floor(g * bins), bins - 1);
                const bbin = Math.min(Math.floor(b * bins), bins - 1);
                
                const binIndex = rbin + gbin * bins + bbin * bins * bins;
                counts[binIndex]++;
            }
            
            return counts;
        }

        function render() {
            const hasVideoSource = video && video.readyState >= video.HAVE_CURRENT_DATA;
            const hasImageSource = uploadedImage && uploadedImage.complete;

            if (!hasVideoSource && !hasImageSource) {
                if (cameraActive) {
                    animationId = requestAnimationFrame(render);
                }
                return;
            }

            const bins = parseFloat(binsSlider.value);

            // Update bin centers if bins changed
            if (bins !== currentBins) {
                currentBins = bins;
                updateBinCentersTexture(bins);
            }

            // Update texture with video or image
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            if (hasVideoSource) {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
            } else if (hasImageSource) {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, uploadedImage);
            }

            gl.uniform1f(binUniformLocation, bins);

            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Update histogram every 5 frames for better performance (or immediately for static image)
            frameCount++;
            if (frameCount % 5 === 0 || !cameraActive) {
                const binCounts = countBins(bins);
                const binCenters = generateBinCenters(bins);
                drawHistogram(binCounts, binCenters, bins);
            }

            if (cameraActive) {
                animationId = requestAnimationFrame(render);
            }
        }

        function stopCamera() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            if (video && video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video = null;
            }
            cameraActive = false;
            startButton.textContent = 'Start Camera';
        }

        async function startCamera() {
            if (cameraActive) {
                stopCamera();
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });

                video = document.createElement('video');
                video.srcObject = stream;
                video.autoplay = true;
                video.playsInline = true;

                video.addEventListener('loadedmetadata', () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    gl.viewport(0, 0, canvas.width, canvas.height);
                    cameraActive = true;
                    uploadedImage = null;
                    startButton.textContent = 'Stop Camera';
                    render();
                });

            } catch (err) {
                showError('Camera access denied or not available: ' + err.message);
            }
        }

        function uploadPhoto() {
            uploadInput.click();
        }

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Stop camera if active
            if (cameraActive) {
                stopCamera();
            }

            const img = new Image();
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;
                gl.viewport(0, 0, canvas.width, canvas.height);
                uploadedImage = img;
                render();
            };
            img.src = URL.createObjectURL(file);
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }

        binsSlider.addEventListener('input', () => {
            binsValue.textContent = binsSlider.value;
            // Re-render if we have a static image
            if (uploadedImage && !cameraActive) {
                render();
            }
        });

        startButton.addEventListener('click', startCamera);
        uploadButton.addEventListener('click', uploadPhoto);
        uploadInput.addEventListener('change', handleImageUpload);

        (async () => {
            if (!await initWebGL()) {
                startButton.disabled = true;
                uploadButton.disabled = true;
            }
        })();

        window.addEventListener('beforeunload', () => {
            stopCamera();
        });
    </script>
</body>
</html>