<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Binning with Histogram</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #fff;
            margin-bottom: 30px;
            font-size: 20px;
            font-weight: 400;
            letter-spacing: 2px;
        }

        .canvas-container {
            width: 100%;
            max-width: 640px;
            margin: 0 auto 20px;
            border: 1px solid #333;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
        }

        #histogramCanvas {
            width: 100%;
            max-width: 640px;
            height: 60px;
            margin: 0 auto 30px;
            border: 1px solid #333;
        }

        .controls {
            max-width: 400px;
            margin: 0 auto;
        }

        .control-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            color: #888;
            margin-bottom: 12px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        input[type="range"] {
            flex: 1;
            height: 2px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.3);
        }

        .value-display {
            font-size: 16px;
            color: #fff;
            min-width: 30px;
            text-align: center;
            font-weight: 300;
        }

        button {
            width: 100%;
            padding: 12px;
            font-size: 12px;
            font-weight: 400;
            border: 1px solid #333;
            background: #000;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #startButton:hover:not(:disabled) {
            border-color: #fff;
            background: #111;
        }

        #startButton:disabled {
            color: #555;
            border-color: #222;
            cursor: not-allowed;
        }

        .error {
            background: #200;
            color: #f88;
            padding: 12px;
            margin-top: 20px;
            display: none;
            font-size: 12px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>COLOR BINNING</h1>
        
        <div class="canvas-container">
            <canvas id="glCanvas" width="640" height="480"></canvas>
        </div>

        <canvas id="histogramCanvas" width="640" height="60"></canvas>

        <div class="controls">
            <div class="control-group">
                <label for="binsSlider">Bins per Channel</label>
                <div class="slider-container">
                    <input type="range" id="binsSlider" min="2" max="11" value="11" step="1">
                    <span class="value-display" id="binsValue">11</span>
                </div>
            </div>

            <div class="control-group">
                <button id="startButton">Start Camera</button>
            </div>
        </div>

        <div class="error" id="errorMessage"></div>
    </div>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        const histCanvas = document.getElementById('histogramCanvas');
        const histCtx = histCanvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const binsSlider = document.getElementById('binsSlider');
        const binsValue = document.getElementById('binsValue');
        const errorMessage = document.getElementById('errorMessage');

        let video = null;
        let texture = null;
        let binCentersTexture = null;
        let program = null;
        let binUniformLocation = null;
        let animationId = null;
        let currentBins = 11;
        let frameCount = 0;

        // Vertex shader
        const vertexShaderSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;

            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = a_texCoord;
            }
        `;

        // Fragment shader - bin centers passed as texture
        const fragmentShaderSource = `
            precision mediump float;
            uniform sampler2D u_texture;
            uniform sampler2D u_binCenters;
            uniform float u_bins;
            varying vec2 v_texCoord;

            void main() {
                vec4 color = texture2D(u_texture, v_texCoord);
                float bins = u_bins;
                
                // Compute bin indices
                float rbin = min(floor(color.r * bins), bins - 1.0);
                float gbin = min(floor(color.g * bins), bins - 1.0);
                float bbin = min(floor(color.b * bins), bins - 1.0);
                
                // Convert 3D bin index to 1D
                float binIndex = rbin + gbin * bins + bbin * bins * bins;
                
                // Total number of bins
                float totalBins = bins * bins * bins;
                
                // Lookup bin center from texture (stored as 1D texture)
                float texCoord = (binIndex + 0.5) / totalBins;
                vec3 binCenter = texture2D(u_binCenters, vec2(texCoord, 0.5)).rgb;
                
                gl_FragColor = vec4(binCenter, color.a);
            }
        `;

        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Pre-calculate all bin centers
        function generateBinCenters(bins) {
            const totalBins = bins * bins * bins;
            const centers = new Float32Array(totalBins * 3);
            
            let idx = 0;
            for (let b = 0; b < bins; b++) {
                for (let g = 0; g < bins; g++) {
                    for (let r = 0; r < bins; r++) {
                        centers[idx++] = (r + 0.5) / bins;
                        centers[idx++] = (g + 0.5) / bins;
                        centers[idx++] = (b + 0.5) / bins;
                    }
                }
            }
            return centers;
        }

        function updateBinCentersTexture(bins) {
            const centers = generateBinCenters(bins);
            const totalBins = bins * bins * bins;
            
            // Create RGB texture (totalBins x 1)
            const rgbData = new Uint8Array(totalBins * 3);
            for (let i = 0; i < totalBins * 3; i++) {
                rgbData[i] = Math.floor(centers[i] * 255);
            }
            
            gl.bindTexture(gl.TEXTURE_2D, binCentersTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, totalBins, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, rgbData);
        }

        function initWebGL() {
            if (!gl) {
                showError('WebGL not supported in this browser');
                return false;
            }

            const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);

            if (!vertexShader || !fragmentShader) {
                showError('Failed to compile shaders');
                return false;
            }

            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                showError('Failed to link program: ' + gl.getProgramInfoLog(program));
                return false;
            }

            gl.useProgram(program);

            const positions = new Float32Array([
                -1, -1,  1, -1,  -1, 1,
                -1, 1,   1, -1,   1, 1
            ]);

            const texCoords = new Float32Array([
                0, 1,  1, 1,  0, 0,
                0, 0,  1, 1,  1, 0
            ]);

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            const texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);

            const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
            gl.enableVertexAttribArray(texCoordLocation);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

            binUniformLocation = gl.getUniformLocation(program, 'u_bins');

            // Create video texture
            texture = gl.createTexture();
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.uniform1i(gl.getUniformLocation(program, 'u_texture'), 0);

            // Create bin centers texture
            binCentersTexture = gl.createTexture();
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, binCentersTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.uniform1i(gl.getUniformLocation(program, 'u_binCenters'), 1);
            
            updateBinCentersTexture(currentBins);

            return true;
        }

        function drawHistogram(binCounts, binCenters, bins) {
            const width = histCanvas.width;
            const height = histCanvas.height;
            
            // Clear with black background
            histCtx.fillStyle = '#000';
            histCtx.fillRect(0, 0, width, height);

            if (binCounts.length === 0) return;

            // Create array of {count, color} for non-empty bins
            const sorted = binCounts.map((count, idx) => ({
                count,
                color: binCenters.slice(idx * 3, idx * 3 + 3)
            })).filter(item => item.count > 0);

            // Sort by luminance (descending) - brightest first
            sorted.sort((a, b) => {
                const lumA = 0.299 * a.color[0] + 0.587 * a.color[1] + 0.114 * a.color[2];
                const lumB = 0.299 * b.color[0] + 0.587 * b.color[1] + 0.114 * b.color[2];
                return lumB - lumA;
            });

            const total = sorted.reduce((sum, item) => sum + item.count, 0);
            
            // Draw horizontal bar (left to right)
            let currentX = 0;
            sorted.forEach(item => {
                const proportion = item.count / total;
                const barWidth = proportion * width;
                
                const r = Math.floor(item.color[0] * 255);
                const g = Math.floor(item.color[1] * 255);
                const b = Math.floor(item.color[2] * 255);
                
                histCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                histCtx.fillRect(currentX, 0, barWidth, height);
                
                currentX += barWidth;
            });
        }

        function countBins(bins) {
            const totalBins = bins * bins * bins;
            const counts = new Array(totalBins).fill(0);
            
            const pixels = new Uint8Array(canvas.width * canvas.height * 4);
            gl.readPixels(0, 0, canvas.width, canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
            
            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i] / 255;
                const g = pixels[i + 1] / 255;
                const b = pixels[i + 2] / 255;
                
                const rbin = Math.min(Math.floor(r * bins), bins - 1);
                const gbin = Math.min(Math.floor(g * bins), bins - 1);
                const bbin = Math.min(Math.floor(b * bins), bins - 1);
                
                const binIndex = rbin + gbin * bins + bbin * bins * bins;
                counts[binIndex]++;
            }
            
            return counts;
        }

        function render() {
            if (!video || video.readyState < video.HAVE_CURRENT_DATA) {
                animationId = requestAnimationFrame(render);
                return;
            }

            const bins = parseFloat(binsSlider.value);
            
            // Update bin centers if bins changed
            if (bins !== currentBins) {
                currentBins = bins;
                updateBinCentersTexture(bins);
            }

            // Update video texture
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);

            gl.uniform1f(binUniformLocation, bins);

            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Update histogram every 5 frames for better performance
            frameCount++;
            if (frameCount % 5 === 0) {
                const binCounts = countBins(bins);
                const binCenters = generateBinCenters(bins);
                drawHistogram(binCounts, binCenters, bins);
            }

            animationId = requestAnimationFrame(render);
        }

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    } 
                });

                video = document.createElement('video');
                video.srcObject = stream;
                video.autoplay = true;
                video.playsInline = true;

                video.addEventListener('loadedmetadata', () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    gl.viewport(0, 0, canvas.width, canvas.height);
                    render();
                });

                startButton.textContent = 'Camera Active';
                startButton.disabled = true;

            } catch (err) {
                showError('Camera access denied or not available: ' + err.message);
            }
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }

        binsSlider.addEventListener('input', () => {
            binsValue.textContent = binsSlider.value;
        });

        startButton.addEventListener('click', startCamera);

        if (!initWebGL()) {
            startButton.disabled = true;
        }

        window.addEventListener('beforeunload', () => {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            if (video && video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
            }
        });
    </script>
</body>
</html>