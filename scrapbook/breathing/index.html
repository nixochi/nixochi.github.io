<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nested Permutahedra</title>

    <!-- DNS prefetch and preconnect for CDNs -->
    <link rel="dns-prefetch" href="https://esm.sh">
    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
    <link rel="preconnect" href="https://esm.sh" crossorigin>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

    <!-- Critical inline CSS for instant rendering -->
    <style>
        /* CSS Variables for theming */
        :root {
            --bg-primary: #000000;
            --fg-primary: #ffffff;
            --fg-secondary: #888888;
            --border: #333333;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg-primary);
            font-family: monospace;
            color: var(--fg-primary);
            height: 100vh;
            height: -webkit-fill-available;
            height: 100svh;
        }

        canvas {
            display: block;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        canvas.ready {
            opacity: 1;
        }

        /* Loading skeleton - shows immediately */
        .skeleton-loader {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-primary);
            z-index: 999;
            transition: opacity 0.3s ease;
        }

        .skeleton-loader.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .skeleton-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--fg-secondary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @media (prefers-reduced-motion: reduce) {
            .skeleton-spinner {
                animation: none;
                border-top-color: var(--border);
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .skeleton-text {
            font-size: 14px;
            color: var(--fg-secondary);
        }
    </style>
</head>
<body>
    <!-- Loading skeleton - shows immediately, removed when ready -->
    <div class="skeleton-loader" id="skeleton" aria-live="polite" aria-label="Loading breathing visualization">
        <div class="skeleton-spinner"></div>
    <div class="skeleton-text">Loading</div>
    </div>

    <script type="module">
        // Resource tracking for cleanup
        const resources = {
            geometries: new Set(),
            materials: new Set(),
            objects: new Set()
        };

        function trackGeometry(geometry) {
            resources.geometries.add(geometry);
            return geometry;
        }

        function trackMaterial(material) {
            resources.materials.add(material);
            return material;
        }

        function trackObject(object) {
            resources.objects.add(object);
            return object;
        }

        function disposeAllResources() {
            resources.geometries.forEach(g => g.dispose?.());
            resources.materials.forEach(m => m.dispose?.());
            resources.objects.forEach(o => o.dispose?.());
            resources.geometries.clear();
            resources.materials.clear();
            resources.objects.clear();
            console.log('🧹 All resources disposed');
        }

        // Fallback CDN import helper
        async function importFirst(urls) {
            let lastError;
            for (const url of urls) {
                try {
                    console.log(`📥 Attempting to load: ${url}`);
                    return await import(/* @vite-ignore */ url);
                } catch (error) {
                    lastError = error;
                    console.warn(`❌ Failed to load ${url}:`, error);
                }
            }
            throw lastError || new Error('All module imports failed');
        }

        // Remove skeleton loader
        function removeLoadingSkeleton() {
            const skeleton = document.getElementById('skeleton');
            if (skeleton) {
                console.log('🎨 Removing loading skeleton - breathing is ready');
                skeleton.classList.add('fade-out');
                setTimeout(() => skeleton.remove(), 300);
            }
        }

        // Main initialization function
        async function initialize() {
            console.log('🚀 Initializing Breathing...');

            // Load THREE.js modules with tree-shaking (only what we need)
            console.log('📦 Loading THREE.js dependencies with tree-shaking...');

            const [
                { Scene },
                { PerspectiveCamera },
                { WebGLRenderer },
                { Group },
                { Vector2 }
            ] = await Promise.all([
                import('https://esm.sh/three@0.160.0/src/scenes/Scene.js'),
                import('https://esm.sh/three@0.160.0/src/cameras/PerspectiveCamera.js'),
                import('https://esm.sh/three@0.160.0/src/renderers/WebGLRenderer.js'),
                import('https://esm.sh/three@0.160.0/src/objects/Group.js'),
                import('https://esm.sh/three@0.160.0/src/math/Vector2.js')
            ]);

            // Create minimal THREE namespace
            const THREE = { Scene, PerspectiveCamera, WebGLRenderer, Group, Vector2 };

            // Load OrbitControls with fallback
            const orbitMod = await importFirst([
                'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js',
                'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js'
            ]);
            const OrbitControls = orbitMod.OrbitControls;

            // Load Line2, LineMaterial, LineGeometry with fallback
            const [line2Mod, lineMaterialMod, lineGeometryMod] = await Promise.all([
                importFirst([
                    'https://esm.sh/three@0.160.0/examples/jsm/lines/Line2.js',
                    'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/lines/Line2.js'
                ]),
                importFirst([
                    'https://esm.sh/three@0.160.0/examples/jsm/lines/LineMaterial.js',
                    'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/lines/LineMaterial.js'
                ]),
                importFirst([
                    'https://esm.sh/three@0.160.0/examples/jsm/lines/LineGeometry.js',
                    'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/lines/LineGeometry.js'
                ])
            ]);

            const Line2 = line2Mod.Line2;
            const LineMaterial = lineMaterialMod.LineMaterial;
            const LineGeometry = lineGeometryMod.LineGeometry;

            // Load QuickHull with fallback
            const qhMod = await importFirst([
                'https://esm.sh/quickhull3d@3.1.1',
                'https://cdn.jsdelivr.net/npm/quickhull3d@3.1.1/+esm'
            ]);
            const qh = qhMod.default || qhMod.quickhull3d || qhMod.qh || qhMod;

            console.log('✅ Dependencies loaded successfully with tree-shaking');

            // Permutahedron vertices
            const permutahedronVertices = [
                [-2.121320343559642, -0.408248290463863,  0.577350269189626],
                [-2.121320343559642,  0.408248290463863, -0.577350269189626],
                [-1.414213562373095, -1.632993161855452,  0.577350269189626],
                [-1.414213562373095,  0.000000000000000, -1.732050807568877],
                [-1.414213562373095,  0.000000000000000,  1.732050807568877],
                [-1.414213562373095,  1.632993161855452, -0.577350269189626],
                [-0.707106781186548, -2.041241452319315, -0.577350269189626],
                [-0.707106781186548, -1.224744871391589, -1.732050807568877],
                [-0.707106781186548, -1.224744871391589,  1.732050807568877],
                [-0.707106781186548,  1.224744871391589, -1.732050807568877],
                [-0.707106781186548,  1.224744871391589,  1.732050807568877],
                [-0.707106781186548,  2.041241452319315,  0.577350269189626],
                [ 0.707106781186548, -2.041241452319315, -0.577350269189626],
                [ 0.707106781186548, -1.224744871391589, -1.732050807568877],
                [ 0.707106781186548, -1.224744871391589,  1.732050807568877],
                [ 0.707106781186548,  1.224744871391589, -1.732050807568877],
                [ 0.707106781186548,  1.224744871391589,  1.732050807568877],
                [ 0.707106781186548,  2.041241452319315,  0.577350269189626],
                [ 1.414213562373095, -1.632993161855452,  0.577350269189626],
                [ 1.414213562373095,  0.000000000000000, -1.732050807568877],
                [ 1.414213562373095,  0.000000000000000,  1.732050807568877],
                [ 1.414213562373095,  1.632993161855452, -0.577350269189626],
                [ 2.121320343559642, -0.408248290463863,  0.577350269189626],
                [ 2.121320343559642,  0.408248290463863, -0.577350269189626]
            ];

            // Scene setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
            document.body.appendChild(renderer.domElement);

            // Add orbit controls
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;
            controls.zoomSpeed = 1.2;

            // Get edges from faces
            function getEdgesFromFaces(faces) {
                const edgeSet = new Set();

                faces.forEach(face => {
                    if (!face || face.length < 3) return;

                    const n = face.length;
                    for (let i = 0; i < n; i++) {
                        const a = face[i];
                        const b = face[(i + 1) % n];

                        const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                        edgeSet.add(key);
                    }
                });

                return Array.from(edgeSet, key => {
                    const [a, b] = key.split('-').map(Number);
                    return [a, b];
                });
            }

            // Global rendering parameters
            let lineThickness = 1.5;
            let polytopeSpacing = 0.29;

            // Create permutahedron wireframe geometry
            function createPermutahedron(scale, color, opacity) {
                const group = new THREE.Group();
                trackObject(group);

                // Get faces using QuickHull
                const faces = qh(permutahedronVertices, { skipTriangulation: true });

                // Get edges from faces
                const edges = getEdgesFromFaces(faces);

                // Create line for each edge using Line2 for proper thickness support
                edges.forEach(([a, b]) => {
                    const vertexA = permutahedronVertices[a];
                    const vertexB = permutahedronVertices[b];

                    const geometry = new LineGeometry();
                    const positions = [
                        vertexA[0], vertexA[1], vertexA[2],
                        vertexB[0], vertexB[1], vertexB[2]
                    ];
                    geometry.setPositions(positions);
                    trackGeometry(geometry);

                    const material = new LineMaterial({
                        color: color,
                        linewidth: lineThickness,
                        transparent: true,
                        opacity: opacity,
                        resolution: new THREE.Vector2(window.innerWidth, window.innerHeight)
                    });
                    trackMaterial(material);

                    const line = new Line2(geometry, material);
                    trackObject(line);
                    group.add(line);
                });

                group.scale.set(scale, scale, scale);
                group.userData.baseScale = scale;
                group.userData.color = color;
                group.userData.opacity = opacity;
                return group;
            }

            // Create 5 nested permutahedra at different scales
            const permutahedra = [
                createPermutahedron(0.1, 0xffffff, 0.95),   // Smallest, white
                createPermutahedron(0.3, 0x3366ff, 0.85),   // Small, blue
                createPermutahedron(0.5, 0x00ff66, 0.75),   // Medium, green
                createPermutahedron(0.7, 0xffcc00, 0.65),   // Large, gold
                createPermutahedron(0.9, 0xff3366, 0.55)    // Largest, red-pink
            ];

            // Function to update polytope spacing
            function updatePolytopeSpacing() {
                permutahedra.forEach((p, i) => {
                    const newScale = (i + 1) * polytopeSpacing;
                    p.scale.set(newScale, newScale, newScale);
                    p.userData.baseScale = newScale;
                });
            }

            permutahedra.forEach(p => scene.add(p));

            // Apply initial spacing
            updatePolytopeSpacing();

            // Position camera
            camera.position.z = 8;

            // Animation state
            let time = 0;
            let cycleDuration = 23400;
            let syncRotationSpeed = 0.00769;
            let easingPower = 2;
            let offsetMultiplier = 1.5;

            // Sync target angle (continuously rotating)
            let syncAngleX = 0;
            let syncAngleY = 0;

            // Base offsets
            const baseOffsets = [
                { x: 0, y: 0 },
                { x: 0.15, y: 0.18 },
                { x: 0.30, y: 0.36 },
                { x: 0.45, y: 0.54 },
                { x: 0.60, y: 0.72 }
            ];

            // Size variation factors
            const sizeVariationFactors = [
                -0.45, // Smallest: shrinks to 55% of base
                -0.22, // Gets smaller
                0.0,   // Middle stays at base
                0.22,  // Gets larger
                0.45   // Largest: grows to 145% of base
            ];

            // Random phase offsets for size oscillation
            const sizePhaseOffsets = [
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2
            ];

            // Dynamic easing function
            function easeInOutDynamic(t, power) {
                const divisor = Math.pow(2, power - 1);
                return t < 0.5 ? divisor * Math.pow(t, power) : 1 - Math.pow(-2 * t + 2, power) / 2;
            }

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);

                const deltaTime = 16; // approximately 60fps
                time += deltaTime;

                // Calculate cycle progress (0 to 1)
                const cycleProgress = (time % cycleDuration) / cycleDuration;

                // Calculate asyncAmount using a sine wave
                const rawCycle = Math.sin(cycleProgress * Math.PI * 2);
                const asyncAmount = easeInOutDynamic(Math.abs(rawCycle), easingPower);

                // Update sync target angle
                syncAngleX += syncRotationSpeed;
                syncAngleY += syncRotationSpeed;

                // Update each permutahedron
                permutahedra.forEach((p, i) => {
                    // Calculate current offset with multiplier
                    const offsetX = baseOffsets[i].x * Math.PI * offsetMultiplier;
                    const offsetY = baseOffsets[i].y * Math.PI * offsetMultiplier;

                    // Set rotation
                    p.rotation.x = syncAngleX + (offsetX * asyncAmount);
                    p.rotation.y = syncAngleY + (offsetY * asyncAmount);

                    // Calculate size variation
                    const sizePhase = cycleProgress * Math.PI * 2 + sizePhaseOffsets[i];
                    const sizeOscillation = Math.sin(sizePhase);
                    const sizeFactor = easeInOutDynamic(Math.abs(sizeOscillation), easingPower);

                    // Calculate scale
                    const baseScale = (i + 1) * polytopeSpacing;
                    const sizeVariation = baseScale * sizeVariationFactors[i];
                    const finalScale = baseScale + (sizeVariation * sizeFactor);

                    p.scale.set(finalScale, finalScale, finalScale);
                });

                // Update controls
                controls.update();

                renderer.render(scene, camera);
            }

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);

                // Update line material resolutions
                permutahedra.forEach(p => {
                    p.traverse(child => {
                        if (child.material && child.material.isLineMaterial) {
                            child.material.resolution.set(window.innerWidth, window.innerHeight);
                        }
                    });
                });
            });

            // Cleanup on page unload
            window.addEventListener('beforeunload', () => {
                disposeAllResources();
                if (controls) controls.dispose();
                if (renderer) renderer.dispose();
            });

            console.log('✅ Breathing initialization complete');

            // Remove skeleton and show canvas
            removeLoadingSkeleton();
            renderer.domElement.classList.add('ready');

            // Start animation
            animate();
        }

        // Defer initialization to next frame to allow skeleton to render
        requestAnimationFrame(() => {
            initialize().catch(err => {
                console.error('❌ Breathing initialization error:', err);
                const skeleton = document.getElementById('skeleton');
                if (skeleton) {
                    skeleton.querySelector('.skeleton-text').textContent = 'Failed to load. Please refresh.';
                    skeleton.querySelector('.skeleton-spinner').style.display = 'none';
                }
            });
        });
    </script>
</body>
</html>
