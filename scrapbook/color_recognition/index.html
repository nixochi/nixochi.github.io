<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Naming - van de Weijer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            padding: 40px;
            background: #f5f5f5;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        h1 {
            margin-bottom: 10px;
            color: #333;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .color-picker-section {
            margin-bottom: 40px;
        }

        .picker-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        select {
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid #ddd;
            background: white;
            font-size: 14px;
            cursor: pointer;
            font-family: inherit;
        }

        select:hover {
            border-color: #999;
        }

        select:focus {
            outline: none;
            border-color: #0066cc;
        }

        .color-display {
            width: 100px;
            height: 100px;
            border-radius: 8px;
            border: 2px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            cursor: pointer;
            position: relative;
        }

        .color-display:hover {
            border-color: #999;
        }

        input[type="color"] {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .picker-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .input-group label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }

        .input-group input[type="text"] {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #333;
            background: #f5f5f5;
            padding: 8px 12px;
            border-radius: 4px;
            border: 2px solid #ddd;
            width: 150px;
        }

        .input-group input[type="text"]:focus {
            outline: none;
            border-color: #0066cc;
            background: white;
        }

        .histogram-section {
            margin-top: 40px;
        }

        h2 {
            margin-bottom: 20px;
            color: #333;
            font-size: 18px;
        }

        .histogram {
            display: flex;
            align-items: flex-end;
            justify-content: flex-start;
            height: 250px;
            padding: 20px;
            background: #fafafa;
            border-radius: 8px;
            gap: 4px;
            overflow-x: auto;
        }

        .bar-container {
            min-width: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .bar-wrapper {
            width: 100%;
            height: 180px;
            display: flex;
            align-items: flex-end;
        }

        .bar {
            width: 100%;
            border-radius: 4px 4px 0 0;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .bar-label {
            font-size: 9px;
            color: #666;
            text-align: center;
            font-weight: 500;
            word-break: break-word;
            hyphens: auto;
            line-height: 1.2;
            max-width: 60px;
        }

        .bar-value {
            font-size: 10px;
            color: #999;
            text-align: center;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            color: #d32f2f;
            padding: 20px;
            background: #ffebee;
            border-radius: 8px;
            margin-top: 20px;
        }

        /* Debug Console */
        #debugConsole {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 300px;
            background: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            overflow-y: auto;
            border-top: 2px solid #333;
            display: none;
            z-index: 10000;
        }

        #debugConsole.visible {
            display: block;
        }

        #debugHeader {
            position: sticky;
            top: 0;
            background: #252526;
            padding: 8px;
            margin: -10px -10px 10px -10px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #debugTitle {
            color: #4ec9b0;
            font-weight: bold;
        }

        #debugClear {
            background: #333;
            color: #d4d4d4;
            border: none;
            padding: 4px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
        }

        #debugClear:hover {
            background: #444;
        }

        .debug-entry {
            padding: 4px 0;
            border-bottom: 1px solid #2d2d2d;
        }

        .debug-log {
            color: #d4d4d4;
        }

        .debug-error {
            color: #f48771;
        }

        .debug-warn {
            color: #dcdcaa;
        }

        .debug-info {
            color: #4fc1ff;
        }

        .debug-timestamp {
            color: #858585;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Color Naming</h1>
        <p class="subtitle">Based on van de Weijer et al., "Learning Color Names for Real-World Applications" (IEEE TIP 2009)</p>

        <div class="color-picker-section">
            <div class="picker-controls">
                <div class="color-display" id="colorDisplay">
                    <input type="color" id="colorPicker" value="#ff0000">
                </div>
                <div class="picker-wrapper">
                    <div class="input-group">
                        <label for="hexInput">Hex</label>
                        <input type="text" id="hexInput" value="#ff0000" maxlength="7">
                    </div>
                    <div class="input-group">
                        <label for="rgbInput">RGB</label>
                        <input type="text" id="rgbInput" value="255, 0, 0">
                    </div>
                </div>
                <select id="colorSetSelector">
                    <option value="11">11 Colors (Basic)</option>
                    <option value="39">39 Colors (Extended)</option>
                </select>
            </div>
        </div>

        <div class="histogram-section">
            <h2>Color Name Probabilities</h2>
            <div id="histogramContainer">
                <div class="loading">Loading color naming data...</div>
            </div>
        </div>
    </div>

    <!-- Debug Console -->
    <div id="debugConsole">
        <div id="debugHeader">
            <span id="debugTitle">Debug Console (Press 'D' to toggle)</span>
            <button id="debugClear">Clear</button>
        </div>
        <div id="debugOutput"></div>
    </div>

    <script>
        // Debug Console Setup
        const debugConsole = document.getElementById('debugConsole');
        const debugOutput = document.getElementById('debugOutput');
        const debugClear = document.getElementById('debugClear');

        function addDebugEntry(message, type = 'log') {
            const entry = document.createElement('div');
            entry.className = `debug-entry debug-${type}`;

            const timestamp = new Date().toLocaleTimeString();
            const timestampSpan = document.createElement('span');
            timestampSpan.className = 'debug-timestamp';
            timestampSpan.textContent = `[${timestamp}]`;

            entry.appendChild(timestampSpan);
            entry.appendChild(document.createTextNode(message));

            debugOutput.appendChild(entry);
            debugOutput.scrollTop = debugOutput.scrollHeight;
        }

        // Intercept console methods
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;
        const originalInfo = console.info;

        console.log = function(...args) {
            originalLog.apply(console, args);
            addDebugEntry(args.join(' '), 'log');
        };

        console.error = function(...args) {
            originalError.apply(console, args);
            addDebugEntry(args.join(' '), 'error');
        };

        console.warn = function(...args) {
            originalWarn.apply(console, args);
            addDebugEntry(args.join(' '), 'warn');
        };

        console.info = function(...args) {
            originalInfo.apply(console, args);
            addDebugEntry(args.join(' '), 'info');
        };

        // Catch uncaught errors
        window.addEventListener('error', (event) => {
            addDebugEntry(`ERROR: ${event.message} at ${event.filename}:${event.lineno}:${event.colno}`, 'error');
        });

        // Catch unhandled promise rejections
        window.addEventListener('unhandledrejection', (event) => {
            addDebugEntry(`UNHANDLED PROMISE REJECTION: ${event.reason}`, 'error');
        });

        // Toggle debug console with 'D' key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'd' || e.key === 'D') {
                debugConsole.classList.toggle('visible');
            }
        });

        // Clear button
        debugClear.addEventListener('click', () => {
            debugOutput.innerHTML = '';
        });

        // Log initial message
        addDebugEntry('Debug console initialized. Press D to toggle.', 'info');

    </script>

    <script>
        const COLOR_NAMES_11 = [
            { name: 'black', color: '#000000' },
            { name: 'blue', color: '#0000FF' },
            { name: 'brown', color: '#8B4513' },
            { name: 'grey', color: '#808080' },
            { name: 'green', color: '#00FF00' },
            { name: 'orange', color: '#FFA500' },
            { name: 'pink', color: '#FFC0CB' },
            { name: 'purple', color: '#800080' },
            { name: 'red', color: '#FF0000' },
            { name: 'white', color: '#FFFFFF' },
            { name: 'yellow', color: '#FFFF00' }
        ];

        const COLOR_NAMES_39 = [
            { name: 'black', color: '#000000' },
            { name: 'brown', color: '#8B4513' },
            { name: 'blue', color: '#0000FF' },
            { name: 'grey', color: '#808080' },
            { name: 'green', color: '#00FF00' },
            { name: 'orange', color: '#FFA500' },
            { name: 'pink', color: '#FFC0CB' },
            { name: 'purple', color: '#800080' },
            { name: 'red', color: '#FF0000' },
            { name: 'white', color: '#FFFFFF' },
            { name: 'yellow', color: '#FFFF00' },
            { name: 'turquoise', color: '#40E0D0' },
            { name: 'olive green', color: '#556B2F' },
            { name: 'mint green', color: '#98FF98' },
            { name: 'maroon', color: '#800000' },
            { name: 'lavender', color: '#E6E6FA' },
            { name: 'magenta', color: '#FF00FF' },
            { name: 'salmon', color: '#FA8072' },
            { name: 'cyan', color: '#00FFFF' },
            { name: 'rose', color: '#FF007F' },
            { name: 'dark green', color: '#006400' },
            { name: 'pale yellow', color: '#FFFF99' },
            { name: 'beige', color: '#F5F5DC' },
            { name: 'lilac', color: '#C8A2C8' },
            { name: 'olive', color: '#808000' },
            { name: 'fuchsia', color: '#FF00FF' },
            { name: 'mustard', color: '#FFDB58' },
            { name: 'mauve', color: '#E0B0FF' },
            { name: 'dark purple', color: '#301934' },
            { name: 'ochre', color: '#CC7722' },
            { name: 'light blue', color: '#ADD8E6' },
            { name: 'lime green', color: '#32CD32' },
            { name: 'light green', color: '#90EE90' },
            { name: 'peach', color: '#FFE5B4' },
            { name: 'teal', color: '#008080' },
            { name: 'violet', color: '#8F00FF' },
            { name: 'dark purple', color: '#301934' },
            { name: 'burgundy', color: '#800020' },
            { name: 'tan', color: '#D2B48C' }
        ];

        let colorData = new Map(); // Change to Map for RGB-based lookup
        let currentColorSet = '11';
        let COLOR_NAMES = COLOR_NAMES_11;

        // Load and parse w2c.txt or w2c39.txt asynchronously
        async function loadColorData(colorSet = '11') {
            try {
                const filename = colorSet === '39' ? 'w2c39.txt' : 'w2c.txt';
                const expectedProbs = colorSet === '39' ? 39 : 11;

                console.log(`Starting to fetch ${filename}...`);
                const startTime = performance.now();

                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                console.log('Fetch complete, starting to read text...');
                const text = await response.text();
                console.log(`Text loaded: ${(text.length / 1024 / 1024).toFixed(2)} MB`);

                console.log('Parsing data...');
                const lines = text.trim().split('\n');
                console.log(`Found ${lines.length} lines`);

                // Parse in chunks to avoid blocking UI
                colorData.clear();
                const chunkSize = 1000;

                for (let i = 0; i < lines.length; i += chunkSize) {
                    const chunk = lines.slice(i, i + chunkSize);

                    chunk.forEach((line, lineIdx) => {
                        // The file has no line numbers, just raw data
                        const values = line.trim().split(/\s+/);

                        if (colorSet === '11') {
                            // 11 color format: 14 values total (RGB + 11 probs)
                            if (values.length < 14) {
                                return;
                            }

                            if (i === 0 && lineIdx === 0) {
                                console.log(`First line: "${line.substring(0, 100)}"`);
                            }

                            const r = parseFloat(values[0]);
                            const g = parseFloat(values[1]);
                            const b = parseFloat(values[2]);
                            const probs = values.slice(3, 14).map(v => parseFloat(v));

                            // For 11 colors, store by sequential index
                            const rBin = Math.floor(r / 8);
                            const gBin = Math.floor(g / 8);
                            const bBin = Math.floor(b / 8);
                            const index = rBin + 32 * gBin + 32 * 32 * bBin;

                            colorData.set(index, probs);

                            if (i === 0 && lineIdx === 0) {
                                console.log(`First entry: RGB(${r}, ${g}, ${b}) index=${index} -> ${probs.length} probabilities`);
                            }
                        } else {
                            // 39 color format: index + 39 probs
                            const expectedValues = 1 + expectedProbs;
                            if (values.length < expectedValues) {
                                if (i === 0 && lineIdx === 0) {
                                    console.log(`First line has ${values.length} values (expected ${expectedValues})`);
                                }
                                return;
                            }

                            if (i === 0 && lineIdx === 0) {
                                console.log(`First line: "${line.substring(0, 100)}"`);
                            }

                            const index = parseInt(values[0]);
                            const probs = values.slice(1, 1 + expectedProbs).map(v => parseFloat(v));

                            // For 39 colors, store by LAB-computed index
                            colorData.set(index, probs);

                            if (i === 0 && lineIdx === 0) {
                                console.log(`First entry: index=${index} -> ${probs.length} probabilities`);
                            }
                        }
                    });

                    if (i === 0) {
                        console.log(`First chunk: parsed entries from ${chunk.length} lines`);
                    }

                    // Let UI breathe
                    if (i % 10000 === 0 && i > 0) {
                        console.log(`Parsed ${i} / ${lines.length} entries...`);
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                const endTime = performance.now();
                console.log(`Loaded ${colorData.size} color entries in ${(endTime - startTime).toFixed(2)}ms`);
                console.log('Initializing histogram...');
                updateHistogram('#ff0000');
                console.log('Histogram ready!');
            } catch (error) {
                console.error('Failed to load color data:', error);
                document.getElementById('histogramContainer').innerHTML =
                    `<div class="error">Error loading color data: ${error.message}</div>`;
            }
        }

        // RGB to LAB color space conversion
        function rgbToXyz(r, g, b) {
            // Normalize to 0-1
            r = r / 255.0;
            g = g / 255.0;
            b = b / 255.0;

            // Apply gamma correction
            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

            // Convert to XYZ using sRGB matrix
            const x = (r * 0.4124564 + g * 0.3575761 + b * 0.1804375) * 100;
            const y = (r * 0.2126729 + g * 0.7151522 + b * 0.0721750) * 100;
            const z = (r * 0.0193339 + g * 0.1191920 + b * 0.9503041) * 100;

            return [x, y, z];
        }

        function xyzToLab(x, y, z) {
            // Reference white D65
            const xn = 95.047, yn = 100.000, zn = 108.883;
            x = x / xn;
            y = y / yn;
            z = z / zn;

            // Apply LAB function
            const f = (t) => t > 0.008856 ? Math.pow(t, 1/3) : (7.787 * t + 16/116);

            const fx = f(x);
            const fy = f(y);
            const fz = f(z);

            const L = 116 * fy - 16;
            const A = 500 * (fx - fy);
            const B = 200 * (fy - fz);

            return [L, A, B];
        }

        function rgbToLab(r, g, b) {
            const [x, y, z] = rgbToXyz(r, g, b);
            return xyzToLab(x, y, z);
        }

        // Get color probabilities - different methods for 11 vs 39 colors
        function getColorProbabilities(r, g, b) {
            if (currentColorSet === '11') {
                // 11 colors use RGB binning (32x32x32 = 32768 entries)
                // index = floor(R/8) + 32*floor(G/8) + 32*32*floor(B/8)
                const rBin = Math.floor(r / 8);
                const gBin = Math.floor(g / 8);
                const bBin = Math.floor(b / 8);
                const index = rBin + 32 * gBin + 32 * 32 * bBin;

                console.log(`RGB(${r}, ${g}, ${b}) -> bins(${rBin}, ${gBin}, ${bBin}) -> index ${index}`);

                if (index < 0 || index >= colorData.size) {
                    console.error(`Index ${index} out of bounds! colorData.size = ${colorData.size}`);
                    return null;
                }

                const probs = colorData.get(index);
                if (!probs) {
                    console.error(`No data found for index ${index}`);
                    return null;
                }

                return { probs };
            } else {
                // 39 colors use LAB space binning (matching MATLAB exactly)
                // Convert RGB to LAB
                const [L, A, B] = rgbToLab(r, g, b);

                // Compute LAB bin indices
                let LBin = Math.floor(L / 5);
                let ABin = Math.floor(A / 5) + 21;
                let BBin = Math.floor(B / 5) + 21;

                // Clamp to valid ranges
                LBin = Math.max(0, Math.min(19, LBin));
                ABin = Math.max(0, Math.min(41, ABin));
                BBin = Math.max(0, Math.min(41, BBin));

                // Compute index using MATLAB formula
                const index = LBin + 20 * ABin + 20 * 42 * BBin;

                console.log(`RGB(${r}, ${g}, ${b}) -> LAB(${L.toFixed(1)}, ${A.toFixed(1)}, ${B.toFixed(1)}) -> bins(${LBin}, ${ABin}, ${BBin}) -> index ${index}`);

                if (index < 0 || index >= colorData.size) {
                    console.error(`Index ${index} out of bounds! colorData.size = ${colorData.size}`);
                    return null;
                }

                const probs = colorData.get(index);
                if (!probs) {
                    console.error(`No data found for index ${index}`);
                    return null;
                }

                return { probs };
            }
        }

        // Update histogram with probabilities
        function updateHistogram(hexColor) {
            console.log(`updateHistogram called with ${hexColor}, colorData.size = ${colorData.size}`);

            if (colorData.size === 0) {
                console.warn('colorData is empty, skipping histogram update');
                return;
            }

            try {
                // Convert hex to RGB
                const r = parseInt(hexColor.slice(1, 3), 16);
                const g = parseInt(hexColor.slice(3, 5), 16);
                const b = parseInt(hexColor.slice(5, 7), 16);

                console.log(`Converting hex ${hexColor} to RGB(${r}, ${g}, ${b})`);

                // Get color probabilities from lookup table
                const colorProbs = getColorProbabilities(r, g, b);

                if (!colorProbs) {
                    console.error('Failed to get color probabilities');
                    return;
                }

                console.log(`Got probabilities:`, colorProbs.probs);

                // Data is already normalized in the source files
                const sum = colorProbs.probs.reduce((acc, p) => acc + p, 0);
                console.log(`Probability sum: ${sum.toFixed(4)}`);

                // Create array of {color, prob, index} and sort by probability (descending)
                const sortedColors = colorProbs.probs
                    .map((prob, index) => ({ prob, index, color: COLOR_NAMES[index] }))
                    .sort((a, b) => b.prob - a.prob);

                // Create histogram
                const histogram = document.createElement('div');
                histogram.className = 'histogram';

                sortedColors.forEach(({ prob, color }) => {
                    const barContainer = document.createElement('div');
                    barContainer.className = 'bar-container';

                    const barWrapper = document.createElement('div');
                    barWrapper.className = 'bar-wrapper';

                    const bar = document.createElement('div');
                    bar.className = 'bar';
                    bar.style.height = `${prob * 100}%`;
                    bar.style.backgroundColor = color.color;

                    // Add border for white bars
                    if (color.name === 'white') {
                        bar.style.border = '1px solid #ddd';
                    }

                    barWrapper.appendChild(bar);

                    const label = document.createElement('div');
                    label.className = 'bar-label';
                    label.textContent = color.name;

                    const value = document.createElement('div');
                    value.className = 'bar-value';
                    value.textContent = (prob * 100).toFixed(1) + '%';

                    barContainer.appendChild(barWrapper);
                    barContainer.appendChild(label);
                    barContainer.appendChild(value);

                    histogram.appendChild(barContainer);
                });

                console.log('Histogram created, updating container...');
                const container = document.getElementById('histogramContainer');
                container.innerHTML = '';
                container.appendChild(histogram);
                console.log('Histogram container updated successfully');
            } catch (error) {
                console.error('Error in updateHistogram:', error);
            }
        }

        // Event listeners
        const colorPicker = document.getElementById('colorPicker');
        const colorDisplay = document.getElementById('colorDisplay');
        const hexInput = document.getElementById('hexInput');
        const rgbInput = document.getElementById('rgbInput');
        const colorSetSelector = document.getElementById('colorSetSelector');

        function updateAllFromHex(hexColor) {
            // Ensure hex starts with #
            if (!hexColor.startsWith('#')) {
                hexColor = '#' + hexColor;
            }

            // Validate hex
            if (!/^#[0-9A-Fa-f]{6}$/.test(hexColor)) {
                return;
            }

            colorDisplay.style.backgroundColor = hexColor;
            colorPicker.value = hexColor;
            hexInput.value = hexColor;

            // Update RGB
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            rgbInput.value = `${r}, ${g}, ${b}`;

            updateHistogram(hexColor);
        }

        function updateAllFromRgb(r, g, b) {
            // Clamp values
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            const hexColor = '#' + [r, g, b].map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');

            colorDisplay.style.backgroundColor = hexColor;
            colorPicker.value = hexColor;
            hexInput.value = hexColor;
            rgbInput.value = `${r}, ${g}, ${b}`;

            updateHistogram(hexColor);
        }

        colorPicker.addEventListener('input', (e) => {
            updateAllFromHex(e.target.value);
        });

        hexInput.addEventListener('input', (e) => {
            updateAllFromHex(e.target.value);
        });

        rgbInput.addEventListener('input', (e) => {
            const parts = e.target.value.split(',').map(s => parseInt(s.trim()));
            if (parts.length === 3 && parts.every(n => !isNaN(n))) {
                updateAllFromRgb(parts[0], parts[1], parts[2]);
            }
        });

        colorSetSelector.addEventListener('change', async (e) => {
            currentColorSet = e.target.value;
            COLOR_NAMES = currentColorSet === '39' ? COLOR_NAMES_39 : COLOR_NAMES_11;

            console.log(`Switching to ${currentColorSet} color set...`);
            document.getElementById('histogramContainer').innerHTML = '<div class="loading">Loading color naming data...</div>';

            await loadColorData(currentColorSet);
        });

        // Initialize
        updateAllFromHex(colorPicker.value);
        loadColorData(currentColorSet);
    </script>
</body>
</html>
